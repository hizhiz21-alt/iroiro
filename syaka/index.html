<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚·ãƒ£ã‚«ã‚·ãƒ£ã‚«ãƒ»ãƒãƒ³ã‚¹ãƒˆãƒƒãƒ—</title>
    <style>
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; position: fixed; background: #f0f0f0;
            touch-action: none;
        }
        .box {
            position: absolute;
            will-change: transform;
            display: inline-block;
            transition: none; /* å‹æ‰‹ãªã‚¢ãƒ‹ãƒ¡ã‚’ã‚ªãƒ• */
        }
        .box img { 
            width: 100px; /* æ¨ªå¹…å›ºå®š */
            height: auto; 
            display: block;
            pointer-events: none; 
            user-select: none;
        }
        button {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; font-size: 20px; z-index: 1000;
            border-radius: 50px; border: none; background: #333; color: white;
        }
    </style>
</head>
<body>

    <button id="startBtn">ã‚·ãƒ£ã‚«ã‚·ãƒ£ã‚«é–‹å§‹ï¼ ğŸ”¥</button>

    <script>
        const boxes = [];
        const btn = document.getElementById('startBtn');
        const numImages = 9;
        const FIXED_WIDTH = 100;

        // å…¨ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ç”¨
        let loadedCount = 0;

        for (let i = 1; i <= numImages; i++) {
            const div = document.createElement('div');
            div.className = 'box';
            const img = new Image();
            img.src = `${i}.png`;
            div.appendChild(img);
            document.body.appendChild(div);

            const data = {
                el: div,
                px: Math.random() * (window.innerWidth - FIXED_WIDTH),
                py: Math.random() * (window.innerHeight - FIXED_WIDTH),
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                angle: Math.random() * 360,
                va: 0,
                w: FIXED_WIDTH,
                h: 0,
                isDragging: false
            };

            img.onload = () => {
                const ratio = img.naturalHeight / img.naturalWidth;
                data.h = FIXED_WIDTH * ratio;
                loadedCount++;
            };
            boxes.push(data);
        }

        btn.addEventListener('click', () => {
            if (loadedCount < numImages) {
                alert("ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­ã§ã™ã€‚ã‚‚ã†ä¸€åº¦æŠ¼ã—ã¦ã¿ã¦ï¼");
                return;
            }
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(state => { if (state === 'granted') run(); });
            } else { run(); }
            btn.style.display = 'none';
        });

        function run() {
            window.addEventListener("devicemotion", (e) => {
                let ag = e.accelerationIncludingGravity;
                if (!ag.x) return;
                boxes.forEach(b => {
                    if (!b.isDragging) {
                        b.vx -= ag.x * 0.7;
                        b.vy += ag.y * 0.7;
                        b.va += ag.x * 0.4;
                    }
                });
            });

            // å¼·åŠ›ãªè¡çªåˆ¤å®šã¨æŠ¼ã—å‡ºã—
            function resolveCollisions() {
                for (let i = 0; i < boxes.length; i++) {
                    for (let j = i + 1; j < boxes.length; j++) {
                        let a = boxes[i];
                        let b = boxes[j];

                        // é•·æ–¹å½¢åŒå£«ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯
                        if (a.px < b.px + b.w && a.px + a.w > b.px &&
                            a.py < b.py + b.h && a.py + a.h > b.py) {
                            
                            // ã©ã£ã¡æ–¹å‘ã«é‡ãªã£ã¦ã‚‹ã‹è¨ˆç®—
                            let overlapX = Math.min(a.px + a.w, b.px + b.w) - Math.max(a.px, b.px);
                            let overlapY = Math.min(a.py + a.h, b.py + b.h) - Math.max(a.py, b.py);

                            if (overlapX < overlapY) {
                                // æ¨ªæ–¹å‘ã«æŠ¼ã—è¿”ã™
                                let dir = (a.px < b.px) ? -1 : 1;
                                a.px += dir * overlapX * 0.5;
                                b.px -= dir * overlapX * 0.5;
                                a.vx *= -0.5; b.vx *= -0.5;
                            } else {
                                // ç¸¦æ–¹å‘ã«æŠ¼ã—è¿”ã™
                                let dir = (a.py < b.py) ? -1 : 1;
                                a.py += dir * overlapY * 0.5;
                                b.py -= dir * overlapY * 0.5;
                                a.vy *= -0.5; b.vy *= -0.5;
                            }
                            // ã¶ã¤ã‹ã£ãŸã‚‰ã¡ã‚‡ã£ã¨å›ã™
                            a.va += (a.vx - b.vx) * 0.1;
                        }
                    }
                }
            }

            function update() {
                resolveCollisions();

                boxes.forEach(b => {
                    if (!b.isDragging) {
                        b.vx *= 0.94; b.vy *= 0.94; b.va *= 0.92;
                        b.px += b.vx; b.py += b.vy; b.angle += b.va;

                        // å£åˆ¤å®š
                        if (b.px < 0) { b.px = 0; b.vx *= -0.8; }
                        if (b.px > window.innerWidth - b.w) { b.px = window.innerWidth - b.w; b.vx *= -0.8; }
                        if (b.py < 0) { b.py = 0; b.vy *= -0.8; }
                        if (b.py > window.innerHeight - b.h) { b.py = window.innerHeight - b.h; b.vy *= -0.8; }
                    }
                    b.el.style.transform = `translate(${b.px}px, ${b.py}px) rotate(${b.angle}deg)`;
                });
                requestAnimationFrame(update);
            }
            update();
        }
    </script>
</body>
</html>
